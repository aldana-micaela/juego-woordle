= Juego Wordle: Trabajo Practico 1 - Programación III
:hardbreaks:
:title-page:
:numbered:
:source-highlighter: coderay
:tabsize: 4

Autores:Aldana Micaela Filiberto <Aldana.filiberto17@gmail.com>; Juliana Camila Nuñez <julicamila14@gmail.com>;
Docentes: Javier Marenco, Patricia Bagnes (Com-01);
 v1, {docdate}.


== Introducción:
El trabajo consiste en la implementación del  juego “Wordle” en el lenguaje Java.
El propósito de este juego es adivinar una palabra secreta de cinco letras que propone la aplicación. Al iniciar el juego, la aplicación selecciona aleatoriamente la palabra secreta de una lista de palabras, y
el usuario debe adivinar la palabra secreta arriesgando palabras por turnos.
En cada turno el usuario le informa al juego una palabra. Si la palabra que introdujo el usuario coincide con la palabra secreta, el usuario gana el juego. Si no, la aplicación le informa al usuario el “status” de cada letra de la palabra.
El usuario tiene diferentes cantidades de intentos para descubrir la palabra secreta. Dependiendo la dificultad que el usuario elija. Si luego de, la cantidad de intentos seleccionada no lo consigue, pierde el juego.

Por último, el juego consiste con la posibilidad de configurar el idioma del juego (Inglés-Español).


== Descripción:
Durante la implementación del juego se nos presentaron varias
dificultades, algunas de ellas fueron:
Permitir que el idioma sea configurable. Primero lo pensamos de esta forma:

.InterfaceJuego

[source, java]
----
 	private void cambiarIdioma() {
		String idioma = menu.getIdioma();
		if (idioma.equals("English")) {
			juego.setIdiomaIngles();
			buildIdiomaIngles();
		} else {
		buildIdiomaEspaol();
    	}
	}

----

Como de esta forma no funcionaba como lo esperabamos, decimos cambiar el constructor de la clase EstadoDeJuego y de la clase JuegoInterface. De esta forma, cuando inicializamos ambas clases se pasa por parametro el idioma y la dificultad.

Esta fue la solución que encontramos para dicho problema.

Otro problema que se nos presentó, fue hacer implementar la dificultad del juego. Al igual que el idioma, lo solucionamos de la misma forma.

También, hicimos cambios al agregar "Enum" en 2 oportunidades: 
			1. Cuándo implementamos el idioma y la dificultad lo hicimos con números, dependiendo que idioma haya elegido el usuario y que
			dificultad, se representaba en la implementación con 1 o 0 para el idioma(Español e Inglés) y 1, 2 y 3 para la dificultad(Fácil, 
			Normal y Difícil).

			2. Al verificar el estado de las letras (acertado, NOacertado, letraEnOtraPosicion) de la palabra que introdujo el usuario, se 
			agregaban a un ArrayList <int> números. Estos números dependiendo el estado de la letra representaban si era acertada, si no lo era, 
			o si la	letra estaba en una posisción incorrecta.

Las decisiones que tomamos rescpeto al juego, fue que el usuario pueda cambiar de palabra solo tres veces. Pero al cambiar la palabra pierde un intento. También decidimos colocar un botón de ayuda en donde le indica al usuario el significado de la palabra. Este botón de ayuda, solo puede ser usado tres veces.

Con respecto a la dificultad, se puede configurar en tres formas:
En el caso de que el usuario seleccione la opción "Fácil" contara con ocho (8) intentos. Pero si el usuario selecciona la opción "Normal" contara con seís (6) intentos. Por último, si el usuario elige la opción "Difícil" solo tendrá cuatro (4) intentos para adivinar la palabra asignada. 


== Implementación:

En total se implementaron 1 clase y 2 interfaces para el correcto funcionamiento del juego.

.[big]#Clase EstadoDeJuego#
[source, java]
----
 	public class EstadoDeJuego {
		//Inicialización de variables.

	public EstadoDeJuego(Idioma idioma, Dificultad dificultad) {

		if (idioma.name().equals("Español")) {
			this.palabrasAux = palabrasEspañol;
			agregarPalabrasEspañol();
			
		} else {
			this.palabrasAux = palabrasIngles;
			agregarPalabrasIngles();

		}
         
		 //Asignación de valores a cada atributo.
		}
----
En el constructor, verifica el idioma para asignar el conjunto de palabras correcto. En el caso de ser "Español", asigna el conjunto palabrasEspañol. De lo contrario, asigna el conjunto palabrasIngles.

[source, java]
----
private void agregarPalabrasEspañol() {
		palabrasEspañolMap = new HashMap<String, String>();
		//Agrega palabras y su significados a PalabrasEspañolMap.

		this.palabraSecreta = elegirPalabra();
		this.pista = palabrasEspañolMap.get(this.palabraSecreta);

	}
----
En este método, se agregan las palabras y su significado al diccionario PalabrasEspañolMap, selecciona una palabra secreta que la guarda en la variable PalabraSecreta y también selecciona la pista de la palabra que se guardo anteriormente y la guarda en la variable pista.
[source, java]
----

	public void cambiarDificultad(Dificultad dif) {
		
		if (dif.name().equals("Fácil")) {
			this.intentos = 8;
		}
		if (dif.name().equals("Normal")) {
			this.intentos = 6;
		}
		if (dif.name().equals("Difícil")) {
			this.intentos = 4;
		}
	}
----

En el siguiente método, dependiendo la dificultad,  se le asigna una cierta cantidad a la variable intentos.

[source, java]
----
public String elegirPalabra() {
		Random random = new Random();

		int elem = random.nextInt(this.palabrasAux.length);

		while (palabrasEnJuego.contains(palabrasAux[elem]) && !palabrasEnJuego.isEmpty())
			elem = random.nextInt(this.palabrasAux.length);

		return this.palabrasAux[elem];
	}
----
El método `elegirPalabra()` elige una palabra de forma aleatoria verificando que esta no sea repetida.

[source, java]
----
public void agregarPalabraAlConjunto() {
		palabrasEnJuego.add(palabraSecreta);

	}
----
El método `agregarPalabraAlConjunto()` agrega la palabra secreta al conjunto palabrasEnJuego.

[source, java]
----
public void limpiarArregloDeNumeros() {
		estadoDeLetras.clear();
	}

----
Este método limpia el arreglo estadoDeLetras.

[source, java]
----
public String obtenerEstadoLetras(int i) {
		return estadoDeLetras.get(i).name();
	}

----
El siguiente método, recibe un índice y  devuelve el elemento que está en la posición i del arrayList de estadoDeLetras.

[source, java]
----
public void vaciarConjuntoDePalabras() {
		palabrasEnJuego.clear();
	}
----
Al igual que el método `vaciarConjuntoDePalabras()` saca los elementos del conjunto palabrasEnJuego.

[source, java]
----
public boolean estaLaLetraEnLaPalabra(char letra) {

		for (int i = 0; i < palabraSecreta.length(); i++) {
			if (palabraSecreta.charAt(i) == letra) {
				return true;
			}
		}
		return false;
	}
----
En este método, verifica que la palabra la letra ingresada esté en la palabra secreta.

[source, java]
----
public void verificarPalabra(String palabraUSER) {

		for (int i = 0; i < palabraSecreta.length(); i++) {

			if (palabraUSER.charAt(i) == palabraSecreta.charAt(i)) {
				estadoDeLetras.add(i, acertado);
			}

			else if (estaLaLetraEnLaPalabra(palabraUSER.charAt(i))) {
				estadoDeLetras.add(i, letraEnOtraPosicion);
			}

			else {
				estadoDeLetras.add(i, noAcertado);
			}

		}
	}
----
El método `verificarPalabra(String palabraUSER)` verifica que la palabra ingresada por el usuario, letra por letra, esté en posición correcta, en otra posición o no esté.

[source, java]
----
public void cambiarPalabra() {
		this.palabraSecreta = elegirPalabra();
		
		if(this.idioma.name().equals("Español"))
			this.pista = palabrasEspañolMap.get(this.palabraSecreta);
		else
			this.pista = palabrasInglesMap.get(this.palabraSecreta);
	}
----

Este método cambia la palabra secreta y dependiendo el idioma la agrega a la pista.

[source, java]
----
public boolean adivinoPalabra(String p) {
		return p.equals(this.palabraSecreta);
	}
----
El método `adivinoPalabra(String p)` verifica que la variable p sea igual a la palabra secreta.

[source, java]
----
public void sumarPuntaje() {
		this.puntaje += 10;

	}
----

Este método suma 10 puntos a la variable puntaje.

[source, java]
----
	public void restarPuntaje() {
		this.puntaje -= 5;
	}
----

Este método resta 5 puntos a la variable puntaje.

== Conclusión:
En conclusión, a pesar de las dificultades que tuvimos aprendimos a utilizar la tecnoligía Window Builder de Java y nos pareció muy interesante la realización de un juego en este lenguaje.

Por momentos nos preocupó como utilizábamos los diferentes métodos y como los implementabamos, pero encontramos la solución. Aprender esta nueva tecnología y el uso de interfaces, fue desafiante pero gratificador para nuestro aprendizaje.
